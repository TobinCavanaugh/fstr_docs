{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Append Definitions From Abstract A simple C library for handling both common and complex dynamic string functionality. Implementation fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 and length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and most functions take care to only allocate when strictly necessary. Getting Started \"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful descriptions will be your friend throughout using fstr.h . Quick Start Guide Quick Examples Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Home"},{"location":"#abstract","text":"A simple C library for handling both common and complex dynamic string functionality.","title":"Abstract"},{"location":"#implementation","text":"fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 and length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and most functions take care to only allocate when strictly necessary.","title":"Implementation"},{"location":"#getting-started","text":"\"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful descriptions will be your friend throughout using fstr.h . Quick Start Guide","title":"Getting Started"},{"location":"#quick-examples","text":"Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Quick Examples"},{"location":"Append/","text":"This is a set of functions relating to appending to fstr types Append C string : fstr_append_C : void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World Append string : fstr_append : void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings Append Character : fstr_append_chr : void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20 Insert string : fstr_insert : void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789 Insert C String : fstr_insert_C : void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789 Append Format C : fstr_append_format_C void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s Pad String : fstr_pad : void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Append"},{"location":"Append/#append-c-string-fstr_append_c","text":"void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World","title":"Append C string : fstr_append_C :"},{"location":"Append/#append-string-fstr_append","text":"void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings","title":"Append string : fstr_append :"},{"location":"Append/#append-character-fstr_append_chr","text":"void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20","title":"Append Character : fstr_append_chr :"},{"location":"Append/#insert-string-fstr_insert","text":"void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789","title":"Insert string : fstr_insert :"},{"location":"Append/#insert-c-string-fstr_insert_c","text":"void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789","title":"Insert C String : fstr_insert_C :"},{"location":"Append/#append-format-c-fstr_append_format_c","text":"void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s","title":"Append Format C : fstr_append_format_C"},{"location":"Append/#pad-string-fstr_pad","text":"void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Pad String : fstr_pad :"},{"location":"Definitions/","text":"String : fstr : The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ; Character : chr : The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t Unsigned Values : usize : usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t Errors : STR_ERR : STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Definitions"},{"location":"Definitions/#string-fstr","text":"The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ;","title":"String : fstr :"},{"location":"Definitions/#character-chr","text":"The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t","title":"Character : chr :"},{"location":"Definitions/#unsigned-values-usize","text":"usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t","title":"Unsigned Values : usize:"},{"location":"Definitions/#errors-str_err","text":"STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Errors : STR_ERR :"},{"location":"From/","text":"This is the set of functions related to creating fstr structs. From C string : fstr_from_C : fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123 From C format string : fstr_from_format_C : fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005 From Length : fstr_from_length : fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From"},{"location":"From/#from-c-string-fstr_from_c","text":"fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123","title":"From C string : fstr_from_C :"},{"location":"From/#from-c-format-string-fstr_from_format_c","text":"fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005","title":"From C format string : fstr_from_format_C :"},{"location":"From/#from-length-fstr_from_length","text":"fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From Length : fstr_from_length :"},{"location":"getting_started/","text":"1. Grab the latest release of the fstr project from https://github.com/TobinCavanaugh/fstr/releases by downloading the fstr.h and fstr.c files to your project source directory. 2. Include fstr.h in the file you wish to use fstr functionality in. 3. Reference fstr.c in your build tool. For CMake, list fstr.c as one of the arguments in add_executable . 4. To create fstr* structs use the from functions. 5. Remember to use fstr_free to free your strings when they're done being used.","title":"Getting started"}]}