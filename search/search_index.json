{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Abstract A simple C library for handling both common and complex dynamic string functionality. Implementation fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 and length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and most functions take care to only allocate when strictly necessary. Getting Started \"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful descriptions will be your friend throughout using fstr.h . Quick Start Guide Quick Examples Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Home"},{"location":"#abstract","text":"A simple C library for handling both common and complex dynamic string functionality.","title":"Abstract"},{"location":"#implementation","text":"fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 and length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and most functions take care to only allocate when strictly necessary.","title":"Implementation"},{"location":"#getting-started","text":"\"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful descriptions will be your friend throughout using fstr.h . Quick Start Guide","title":"Getting Started"},{"location":"#quick-examples","text":"Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Quick Examples"},{"location":"Append/","text":"This is a set of functions relating to appending to fstr types Append C string : fstr_append_C : void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World Append string : fstr_append : void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings Append Character : fstr_append_chr : void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20 Insert string : fstr_insert : void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789 Insert C String : fstr_insert_C : void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789 Append Format C : fstr_append_format_C void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s Pad String : fstr_pad : void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Append"},{"location":"Append/#append-c-string-fstr_append_c","text":"void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World","title":"Append C string : fstr_append_C :"},{"location":"Append/#append-string-fstr_append","text":"void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings","title":"Append string : fstr_append :"},{"location":"Append/#append-character-fstr_append_chr","text":"void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20","title":"Append Character : fstr_append_chr :"},{"location":"Append/#insert-string-fstr_insert","text":"void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789","title":"Insert string : fstr_insert :"},{"location":"Append/#insert-c-string-fstr_insert_c","text":"void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789","title":"Insert C String : fstr_insert_C :"},{"location":"Append/#append-format-c-fstr_append_format_c","text":"void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s","title":"Append Format C : fstr_append_format_C"},{"location":"Append/#pad-string-fstr_pad","text":"void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Pad String : fstr_pad :"},{"location":"Count/","text":"This is a set of functions relating to counting things in fstr . Count C string : fstr_count_C : void fstr * str chr * sub This function counts the instances of the C substring sub within the fstr . fstr * str = fstr_from_C ( \"The quick brown fox jumps over the lazy dog\" ); fstr_to_lower ( str ); usize count = fstr_count_C ( str , \"the\" ); printf ( \"%llu instances of 'the'\" , count ); fstr_free ( str ); 2 instances of 'the' Count string : fstr_count : void fstr * str fstr * sub fstr * str = fstr_from_C ( \"It was the best of times, it was the worst of times\" ); fstr * sub = fstr_from_C ( \"it\" ); fstr_to_lower ( str ); usize count = fstr_count ( str , sub ); printf ( \"%llu instances of '\" , count ); fstr_print ( sub ); printf ( \"'\" ); fstr_free ( str ); fstr_free ( sub ); 2 instances of 'it' Count characters : fstr_count_chr : void fstr * str fstr * sub fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); usize countOfZeros = fstr_count_chr ( str , '0' ); usize countOfOnes = fstr_count_chr ( str , '1' ); printf ( \"Count of zeros: %lld \\n Count of ones: %lld\" , countOfZeros , countOfOnes ); fstr_free ( str ); Count of zeros: 20 Count of ones: 20","title":"Count"},{"location":"Count/#count-c-string-fstr_count_c","text":"void fstr * str chr * sub This function counts the instances of the C substring sub within the fstr . fstr * str = fstr_from_C ( \"The quick brown fox jumps over the lazy dog\" ); fstr_to_lower ( str ); usize count = fstr_count_C ( str , \"the\" ); printf ( \"%llu instances of 'the'\" , count ); fstr_free ( str ); 2 instances of 'the'","title":"Count C string : fstr_count_C :"},{"location":"Count/#count-string-fstr_count","text":"void fstr * str fstr * sub fstr * str = fstr_from_C ( \"It was the best of times, it was the worst of times\" ); fstr * sub = fstr_from_C ( \"it\" ); fstr_to_lower ( str ); usize count = fstr_count ( str , sub ); printf ( \"%llu instances of '\" , count ); fstr_print ( sub ); printf ( \"'\" ); fstr_free ( str ); fstr_free ( sub ); 2 instances of 'it'","title":"Count string : fstr_count :"},{"location":"Count/#count-characters-fstr_count_chr","text":"void fstr * str fstr * sub fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); usize countOfZeros = fstr_count_chr ( str , '0' ); usize countOfOnes = fstr_count_chr ( str , '1' ); printf ( \"Count of zeros: %lld \\n Count of ones: %lld\" , countOfZeros , countOfOnes ); fstr_free ( str ); Count of zeros: 20 Count of ones: 20","title":"Count characters : fstr_count_chr :"},{"location":"Definitions/","text":"fstr definitions contained within fstr.h String : fstr : The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ; Character : chr : The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t Unsigned Values : usize : usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t Errors : STR_ERR : STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Definitions"},{"location":"Definitions/#string-fstr","text":"The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ;","title":"String : fstr :"},{"location":"Definitions/#character-chr","text":"The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t","title":"Character : chr :"},{"location":"Definitions/#unsigned-values-usize","text":"usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t","title":"Unsigned Values : usize:"},{"location":"Definitions/#errors-str_err","text":"STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Errors : STR_ERR :"},{"location":"From/","text":"This is the set of functions related to creating fstr structs. From C string : fstr_from_C : fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123 From C format string : fstr_from_format_C : fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005 From Length : fstr_from_length : fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From"},{"location":"From/#from-c-string-fstr_from_c","text":"fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123","title":"From C string : fstr_from_C :"},{"location":"From/#from-c-format-string-fstr_from_format_c","text":"fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005","title":"From C format string : fstr_from_format_C :"},{"location":"From/#from-length-fstr_from_length","text":"fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From Length : fstr_from_length :"},{"location":"Printing/","text":"This is a set of functions relating to printing. Print : fstr_print : void fstr * str This prints the string directly to stdout by using the fwrite function. This is many dozens of times faster than using printf. fstr * str = fstr_from_C ( \":) \" ); fstr_print ( str ); fstr_print ( str ); fstr_print ( str ); fstr_free ( str ); :) :) :) Print Line : fstr_println : void fstr * str This function also uses fwrite to write to stdio, as well as printing out a newline character using printf . fstr * str = fstr_from_C ( \":) \" ); fstr_println ( str ); fstr_println ( str ); fstr_println ( str ); fstr_free ( str ); :) :) :) Print Characters : fstr_print_chrs : void fstr * str This function writes each character individually using printf(\"%c\") . This is a MUCH slower but possibly more reliable print function in the case that fwrite doesn't properly work. fstr * str = fstr_from_C ( \"0x0x0x\" ); fstr_print_chrs ( str ); 0x0x0x Print Characters Formatted : fstr_print_chrs_f : void fstr * str chr * format This function prints out each individual character with the formatting applied. This does not take varargs . You must include the %c in the format fstr * str = fstr_from_C ( \"abc\" ); fstr_print_chrs_f ( str , \"[%c]\" ); fstr_free ( str ); [a][b][c] Print Hex Codes : fstr_print_hex : void fstr * str This function prints out each character as its hex code then adds a space separator. fstr * str = fstr_from_C ( \"hex text\" ); fstr_print_hex ( str ); fstr_free ( str ); 0x68 0x65 0x78 0x20 0x74 0x65 0x78 0x74","title":"Printing"},{"location":"Printing/#print-fstr_print","text":"void fstr * str This prints the string directly to stdout by using the fwrite function. This is many dozens of times faster than using printf. fstr * str = fstr_from_C ( \":) \" ); fstr_print ( str ); fstr_print ( str ); fstr_print ( str ); fstr_free ( str ); :) :) :)","title":"Print : fstr_print :"},{"location":"Printing/#print-line-fstr_println","text":"void fstr * str This function also uses fwrite to write to stdio, as well as printing out a newline character using printf . fstr * str = fstr_from_C ( \":) \" ); fstr_println ( str ); fstr_println ( str ); fstr_println ( str ); fstr_free ( str ); :) :) :)","title":"Print Line : fstr_println :"},{"location":"Printing/#print-characters-fstr_print_chrs","text":"void fstr * str This function writes each character individually using printf(\"%c\") . This is a MUCH slower but possibly more reliable print function in the case that fwrite doesn't properly work. fstr * str = fstr_from_C ( \"0x0x0x\" ); fstr_print_chrs ( str ); 0x0x0x","title":"Print Characters : fstr_print_chrs :"},{"location":"Printing/#print-characters-formatted-fstr_print_chrs_f","text":"void fstr * str chr * format This function prints out each individual character with the formatting applied. This does not take varargs . You must include the %c in the format fstr * str = fstr_from_C ( \"abc\" ); fstr_print_chrs_f ( str , \"[%c]\" ); fstr_free ( str ); [a][b][c]","title":"Print Characters Formatted : fstr_print_chrs_f :"},{"location":"Printing/#print-hex-codes-fstr_print_hex","text":"void fstr * str This function prints out each character as its hex code then adds a space separator. fstr * str = fstr_from_C ( \"hex text\" ); fstr_print_hex ( str ); fstr_free ( str ); 0x68 0x65 0x78 0x20 0x74 0x65 0x78 0x74","title":"Print Hex Codes : fstr_print_hex :"},{"location":"Removing/","text":"This is the set of functions relating to removing from strings.","title":"Removing"},{"location":"getting_started/","text":"","title":"Getting started"}]}