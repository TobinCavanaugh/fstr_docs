{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Take me to the documentation Read the source code Abstract A simple C library for handling both common and complex dynamic string functionality. Implementation fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 s and a length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and functions take care to only allocate when strictly necessary. Getting Started \"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful documentation and will be your friend throughout using fstr.h . The code within fstr.c is clear and understandable, but very performant. Quick Start Guide Quick Examples Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } (1): fstr s are made by using the series of from functions. In this case, fstr_from_C Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { //(1) printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Home"},{"location":"#abstract","text":"A simple C library for handling both common and complex dynamic string functionality.","title":"Abstract"},{"location":"#implementation","text":"fstr takes advantage of a novel string implementation. It uses a character array with a pointer to the last character of the string. This allows for strings that support inline \\0 s and a length that only requires one subtraction to calculate. The fstr type is dynamically allocated, and functions take care to only allocate when strictly necessary.","title":"Implementation"},{"location":"#getting-started","text":"\"Good code is its own best documentation\" Steve McConnell fstr was made with the intention of simplicity, it's well commented, and intuitively designed. The header files contain helpful documentation and will be your friend throughout using fstr.h . The code within fstr.c is clear and understandable, but very performant. Quick Start Guide","title":"Getting Started"},{"location":"#quick-examples","text":"Creating and using string: #include \"fstr.h\" int main (){ fstr * str = fstr_from_C ( \"Hello World\" ); //(1) fstr_println ( str ); fstr_free ( str ); } (1): fstr s are made by using the series of from functions. In this case, fstr_from_C Parsing an integer from a string: #include <stdio.h> #include \"fstr.h\" #include \"fstr_parse.h\" int main () { fstr * str = fstr_from_C ( \" 1234 \" ); int64_t value = 0 ; if ( fstr_try_to_i64 ( str , & value )) { //(1) printf ( \"%lld\" , value ); } else { printf ( \"Failed to parse fstr: \" ); fstr_print ( str ); } }","title":"Quick Examples"},{"location":"Append/","text":"This is a set of functions relating to appending to fstr types Append C string : fstr_append_C : void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World Append string : fstr_append : void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings Append Character : fstr_append_chr : void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20 Insert string : fstr_insert : void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789 Insert C String : fstr_insert_C : void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789 Append Format C : fstr_append_format_C void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s Pad String : fstr_pad : void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Append"},{"location":"Append/#append-c-string-fstr_append_c","text":"void fstr * str chr * buf This function appends a C style string (or literal) buf to our fstr . This supports wchar_t . fstr * str = fstr_from_C ( \"Hello\" ); fstr_append_C ( str , \" Cruel World\" ); fstr_println ( str ); fstr_free ( str ); Hello Cruel World","title":"Append C string : fstr_append_C :"},{"location":"Append/#append-string-fstr_append","text":"void fstr * str fstr * buf This function appends our fstr * buf contents to our str . fstr * str = fstr_from_C ( \"Fancy\" ); fstr * other = fstr_from_C ( \" Strings\" ); fstr_append ( str , other ); fstr_println ( str ); fstr_free ( str ); fstr_free ( other ); Fancy Strings","title":"Append string : fstr_append :"},{"location":"Append/#append-character-fstr_append_chr","text":"void fstr * str chr c This function appends the character c to our str . This supports wchar_t fstr * str = fstr_from_C ( \"10 + 10 = \" ); fstr_append_chr ( str , '2' ); fstr_append_chr ( str , '0' ); fstr_println ( str ); fstr_free ( str ); 10 + 10 = 20","title":"Append Character : fstr_append_chr :"},{"location":"Append/#insert-string-fstr_insert","text":"void fstr * str usize index fstr * add This function inserts the fstr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); fstr * add = fstr_from_C ( \"abc\" ); fstr_insert ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); fstr_free ( add ); 0abc123456789","title":"Insert string : fstr_insert :"},{"location":"Append/#insert-c-string-fstr_insert_c","text":"void fstr * str usize index chr * add This function inserts the chr * add at the index within str . fstr * str = fstr_from_C ( \"0123456789\" ); chr * add = \"abc\" ; fstr_insert_C ( str , 1 , add ); fstr_print ( str ); fstr_free ( str ); 0abc123456789","title":"Insert C String : fstr_insert_C :"},{"location":"Append/#append-format-c-fstr_append_format_c","text":"void fstr * str chr * format ... This function appends a C string constructed from a format (think printf() ). #include <time.h> fstr * str = fstr_from_C ( \"Info) \" ); fstr_append_format_C ( str , \"Unix Time is: %llus\" , time ( NULL )); fstr_println ( str ); fstr_free ( str ); Info) Unix Time is: 1711501044s","title":"Append Format C : fstr_append_format_C"},{"location":"Append/#pad-string-fstr_pad","text":"void fstr * str usize targetLength chr pad int8_t side This function pads an fstr to reach the particular length targetLength by placing the padding character repeatedly on a particular side In this and other cases; side < 0 : For padding to occur on the left side side > 0 : For padding to occur on the right side side == 0 : For padding to occur on both sides In the case that both sides padding cannot be equal in length, the extra character will be placed on the right side. If this is an issue, call this function with targetLength - 1 and use fstr_insert with index = 0 to pad the extra character to the length. In the case that targetLength is <= the length of str , nothing will be done. fstr * str = fstr_from_C ( \"Centered\" ); fstr_pad ( str , 16 , '-' , 0 ); fstr_insert_C ( str , 0 , \"|\" ); fstr_insert_C ( str , fstr_length ( str ), \"|\" ); fstr_println ( str ); fstr_free ( str ); |----Centered----|","title":"Pad String : fstr_pad :"},{"location":"CharacterFunctions/","text":"These are all the functions and macros relating to characters. To Upper : chr_to_upper : chr chr a This function uppercases the chr a . This is wchar_t compatible. chr c = 'a' ; printf ( \"%c->%c\" , c , chr_to_upper ( c )); a->A To Lower : chr_to_lower : chr chr a This function lowercases the chr a . This is wchar_t compatible. chr c = 'A' ; printf ( \"%c->%c\" , c , chr_to_lower ( c )); A->a Is Lower : chr_is_lower : bool chr a This is a macro that returns true if the chr a is lowercase, and false if it's uppercase or non alphabetical. chr c = 'a' ; printf ( \"lower:[%d] upper:[%d]\" , chr_is_lower ( c ), chr_is_upper ( c )); lower:[1] upper:[0] Is Upper : chr_is_upper : bool chr a This is a macro that returns true if the chr a is uppercase, and false if it's lowercase or non alphabetical. chr c = 'A' ; printf ( \"lower:[%d] upper:[%d]\" , chr_is_lower ( c ), chr_is_upper ( c )); lower:[0] upper:[1] Using Char : USING_CHAR : This is a C macro that returns 1 if chr is defined as using char and 0 if it's using anything else. This is used a lot throughout the fstr.c file to deal with conditions where wchar_t would produce incorrect output. //From fstr.c void fstr_print ( const fstr * str ) { if ( USING_CHAR ) { usize len = fstr_length ( str ); fwrite ( str -> data , sizeof ( chr ), len , stdout ); } else if ( USING_WCHAR ) { wprintf ( L \"%ls\" , str -> data ); } } Using wchar : USING_WCHAR : This is the counterpart to USING_CHAR that returns 1 if chr is defined as wchar_t and 0 if its using anything else. See [#using-char--]","title":"CharacterFunctions"},{"location":"CharacterFunctions/#to-upper-chr_to_upper","text":"chr chr a This function uppercases the chr a . This is wchar_t compatible. chr c = 'a' ; printf ( \"%c->%c\" , c , chr_to_upper ( c )); a->A","title":"To Upper : chr_to_upper :"},{"location":"CharacterFunctions/#to-lower-chr_to_lower","text":"chr chr a This function lowercases the chr a . This is wchar_t compatible. chr c = 'A' ; printf ( \"%c->%c\" , c , chr_to_lower ( c )); A->a","title":"To Lower : chr_to_lower :"},{"location":"CharacterFunctions/#is-lower-chr_is_lower","text":"bool chr a This is a macro that returns true if the chr a is lowercase, and false if it's uppercase or non alphabetical. chr c = 'a' ; printf ( \"lower:[%d] upper:[%d]\" , chr_is_lower ( c ), chr_is_upper ( c )); lower:[1] upper:[0]","title":"Is Lower : chr_is_lower :"},{"location":"CharacterFunctions/#is-upper-chr_is_upper","text":"bool chr a This is a macro that returns true if the chr a is uppercase, and false if it's lowercase or non alphabetical. chr c = 'A' ; printf ( \"lower:[%d] upper:[%d]\" , chr_is_lower ( c ), chr_is_upper ( c )); lower:[0] upper:[1]","title":"Is Upper : chr_is_upper :"},{"location":"CharacterFunctions/#using-char-using_char","text":"This is a C macro that returns 1 if chr is defined as using char and 0 if it's using anything else. This is used a lot throughout the fstr.c file to deal with conditions where wchar_t would produce incorrect output. //From fstr.c void fstr_print ( const fstr * str ) { if ( USING_CHAR ) { usize len = fstr_length ( str ); fwrite ( str -> data , sizeof ( chr ), len , stdout ); } else if ( USING_WCHAR ) { wprintf ( L \"%ls\" , str -> data ); } }","title":"Using Char : USING_CHAR :"},{"location":"CharacterFunctions/#using-wchar-using_wchar","text":"This is the counterpart to USING_CHAR that returns 1 if chr is defined as wchar_t and 0 if its using anything else. See [#using-char--]","title":"Using wchar : USING_WCHAR :"},{"location":"Count/","text":"This is a set of functions relating to counting things in fstr . Count C string : fstr_count_C : void fstr * str chr * sub This function counts the instances of the C substring sub within the fstr . fstr * str = fstr_from_C ( \"The quick brown fox jumps over the lazy dog\" ); fstr_to_lower ( str ); usize count = fstr_count_C ( str , \"the\" ); printf ( \"%llu instances of 'the'\" , count ); fstr_free ( str ); 2 instances of 'the' Count string : fstr_count : void fstr * str fstr * sub fstr * str = fstr_from_C ( \"It was the best of times, it was the worst of times\" ); fstr * sub = fstr_from_C ( \"it\" ); fstr_to_lower ( str ); usize count = fstr_count ( str , sub ); printf ( \"%llu instances of '\" , count ); fstr_print ( sub ); printf ( \"'\" ); fstr_free ( str ); fstr_free ( sub ); 2 instances of 'it' Count characters : fstr_count_chr : void fstr * str fstr * sub fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); usize countOfZeros = fstr_count_chr ( str , '0' ); usize countOfOnes = fstr_count_chr ( str , '1' ); printf ( \"Count of zeros: %lld \\n Count of ones: %lld\" , countOfZeros , countOfOnes ); fstr_free ( str ); Count of zeros: 20 Count of ones: 20","title":"Count"},{"location":"Count/#count-c-string-fstr_count_c","text":"void fstr * str chr * sub This function counts the instances of the C substring sub within the fstr . fstr * str = fstr_from_C ( \"The quick brown fox jumps over the lazy dog\" ); fstr_to_lower ( str ); usize count = fstr_count_C ( str , \"the\" ); printf ( \"%llu instances of 'the'\" , count ); fstr_free ( str ); 2 instances of 'the'","title":"Count C string : fstr_count_C :"},{"location":"Count/#count-string-fstr_count","text":"void fstr * str fstr * sub fstr * str = fstr_from_C ( \"It was the best of times, it was the worst of times\" ); fstr * sub = fstr_from_C ( \"it\" ); fstr_to_lower ( str ); usize count = fstr_count ( str , sub ); printf ( \"%llu instances of '\" , count ); fstr_print ( sub ); printf ( \"'\" ); fstr_free ( str ); fstr_free ( sub ); 2 instances of 'it'","title":"Count string : fstr_count :"},{"location":"Count/#count-characters-fstr_count_chr","text":"void fstr * str fstr * sub fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); usize countOfZeros = fstr_count_chr ( str , '0' ); usize countOfOnes = fstr_count_chr ( str , '1' ); printf ( \"Count of zeros: %lld \\n Count of ones: %lld\" , countOfZeros , countOfOnes ); fstr_free ( str ); Count of zeros: 20 Count of ones: 20","title":"Count characters : fstr_count_chr :"},{"location":"Definitions/","text":"fstr definitions contained within fstr.h String : fstr : The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ; Character : chr : The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t Unsigned Values : usize : usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t Errors : STR_ERR : STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Definitions"},{"location":"Definitions/#string-fstr","text":"The type fstr is a struct containing three fields; end , error , and *data . end is the pointer to the last character of the string. This is how we determine length. error is the STR_ERROR which we can use to check for errors after function calls. *data is the pointer to the start of our character array. Unlike common C character arrays this is not null terminated. typedef struct { //The address of the last character in our string, inclusive. usize end ; //Whether an error occurred on the string operation STR_ERR error ; //The starting pointer of our string data chr * data ; } fstr ;","title":"String : fstr :"},{"location":"Definitions/#character-chr","text":"The character type in fstr.h is designed to be as flexible as possible. As such we use a macro defining chr as char. Many functions have support for wchar_t directly or incidentally, as such you can change the macro definition of chr to use wchar_t for projects that require wide characters. Using wchar_t may or may not break functions. #define chr char //OR #define chr wchar_t","title":"Character : chr :"},{"location":"Definitions/#unsigned-values-usize","text":"usize is a basic macro wrapper around uintptr_t with the goal being to increase flexibility and cross platform support. usize is often used for lengths, counts, and pointers. #define usize uintptr_t","title":"Unsigned Values : usize:"},{"location":"Definitions/#errors-str_err","text":"STR_ERR is an enum : uint8_t type that allows the user to respond to errors raised by function calls. fstr.h functions will always try to recover gracefully, even in the case of null arguments, and its up to the user to check for errors raised by these functions. The fstr struct has the field STR_ERR error which gets assigned with a value in the case of an error. typedef enum : uint8_t { STR_ERR_None = 0 , STR_ERR_IndexOutOfBounds = 1 , STR_ERR_AllocFailed = 2 , STR_ERR_ReallocFailed = 3 , STR_ERR_NullStringArg = 4 , STR_ERR_INCORRECT_CHAR_POINTER = 5 } STR_ERR ;","title":"Errors : STR_ERR :"},{"location":"Docpage/","text":"Links to all the documentation. Appending To Strings Character Functions Counting In Strings Definitions Freeing and Clearing From/Creating Strings Printing Strings Removing From Strings","title":"Documentation"},{"location":"Free/","text":"This is a set of functions about freeing or clearing strings. Free : fstr_free : void fstr * str This function frees the string. Do NOT use free to free strings, as the string data will continue to be allocated. Other libraries might call this destroy , release , dealloc , or dispose . fstr * str = fstr_from_C ( \"Sometimes, the elegant implementation is just a function. Not a method. Not a class. Not a framework. Just a function.\" ); fstr_free ( str ); Clear : fstr_clear : void fstr * str This function clears the contents of the string and makes it so the length is 0. This is not the same as freeing it, as afterwards you can perform more operations on the string, such as appending to it. fstr * str = fstr_from_C ( \"Low-level programming is good for the programmer's soul.\" ); fstr_println ( str ); fstr_clear ( str ); fstr_append_C ( str , \":)\" ); fstr_println ( str ); Low-level programming is good for the programmer's soul. :)","title":"Free"},{"location":"Free/#free-fstr_free","text":"void fstr * str This function frees the string. Do NOT use free to free strings, as the string data will continue to be allocated. Other libraries might call this destroy , release , dealloc , or dispose . fstr * str = fstr_from_C ( \"Sometimes, the elegant implementation is just a function. Not a method. Not a class. Not a framework. Just a function.\" ); fstr_free ( str );","title":"Free : fstr_free :"},{"location":"Free/#clear-fstr_clear","text":"void fstr * str This function clears the contents of the string and makes it so the length is 0. This is not the same as freeing it, as afterwards you can perform more operations on the string, such as appending to it. fstr * str = fstr_from_C ( \"Low-level programming is good for the programmer's soul.\" ); fstr_println ( str ); fstr_clear ( str ); fstr_append_C ( str , \":)\" ); fstr_println ( str ); Low-level programming is good for the programmer's soul. :)","title":"Clear : fstr_clear :"},{"location":"From/","text":"This is the set of functions related to creating fstr structs. From C string : fstr_from_C : fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123 From C format string : fstr_from_format_C : fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005 From Length : fstr_from_length : fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From"},{"location":"From/#from-c-string-fstr_from_c","text":"fstr * chr * str This creates an fstr from a C string literal. Supports wchar_t via the use of L prefixed string literals. fstr * str = fstr_from_C ( \"abc123\" ); fstr_println ( str ); fstr_free ( str ); abc123","title":"From C string : fstr_from_C :"},{"location":"From/#from-c-format-string-fstr_from_format_c","text":"fstr * chr * format ... This creates an fstr from a C format. This takes in a C format (think printf format) and creates an fstr from it. This takes a variable amount of arguments. fstr * str = fstr_from_format_C ( \"%02d-%02d-%d\" , 4 , 12 , 2005 ); fstr_println ( str ); fstr_free ( str ); 04-12-2005","title":"From C format string : fstr_from_format_C :"},{"location":"From/#from-length-fstr_from_length","text":"fstr * u64 length chr fill This creates an fstr of a particular length filled with a particular chr . fstr * str = fstr_from_length ( 5 , '0' ); fstr_println ( str ); fstr_free ( str ); 00000","title":"From Length : fstr_from_length :"},{"location":"Misc/","text":"These are all the functions in fstr.h that don't fit into the other categories. Reverse : fstr_reverse : Set Chr : fstr_set_chr : To Lower : fstr_to_lower : To Upper : fstr_to_upper : Invert Case : fstr_invertcase :","title":"Misc"},{"location":"Misc/#reverse-fstr_reverse","text":"","title":"Reverse : fstr_reverse :"},{"location":"Misc/#set-chr-fstr_set_chr","text":"","title":"Set Chr : fstr_set_chr :"},{"location":"Misc/#to-lower-fstr_to_lower","text":"","title":"To Lower : fstr_to_lower :"},{"location":"Misc/#to-upper-fstr_to_upper","text":"","title":"To Upper : fstr_to_upper :"},{"location":"Misc/#invert-case-fstr_invertcase","text":"","title":"Invert Case : fstr_invertcase :"},{"location":"Printing/","text":"This is a set of functions relating to printing. Print : fstr_print : void fstr * str This prints the string directly to stdout by using the fwrite function. This is many dozens of times faster than using printf. fstr * str = fstr_from_C ( \":) \" ); fstr_print ( str ); fstr_print ( str ); fstr_print ( str ); fstr_free ( str ); :) :) :) Print Line : fstr_println : void fstr * str This function also uses fwrite to write to stdio, as well as printing out a newline character using printf . fstr * str = fstr_from_C ( \":) \" ); fstr_println ( str ); fstr_println ( str ); fstr_println ( str ); fstr_free ( str ); :) :) :) Print Characters : fstr_print_chrs : void fstr * str This function writes each character individually using printf(\"%c\") . This is a MUCH slower but possibly more reliable print function in the case that fwrite doesn't properly work. fstr * str = fstr_from_C ( \"0x0x0x\" ); fstr_print_chrs ( str ); 0x0x0x Print Characters Formatted : fstr_print_chrs_f : void fstr * str chr * format This function prints out each individual character with the formatting applied. This does not take varargs . You must include the %c in the format fstr * str = fstr_from_C ( \"abc\" ); fstr_print_chrs_f ( str , \"[%c]\" ); fstr_free ( str ); [a][b][c] Print Hex Codes : fstr_print_hex : void fstr * str This function prints out each character as its hex code then adds a space separator. fstr * str = fstr_from_C ( \"hex text\" ); fstr_print_hex ( str ); fstr_free ( str ); 0x68 0x65 0x78 0x20 0x74 0x65 0x78 0x74","title":"Printing"},{"location":"Printing/#print-fstr_print","text":"void fstr * str This prints the string directly to stdout by using the fwrite function. This is many dozens of times faster than using printf. fstr * str = fstr_from_C ( \":) \" ); fstr_print ( str ); fstr_print ( str ); fstr_print ( str ); fstr_free ( str ); :) :) :)","title":"Print : fstr_print :"},{"location":"Printing/#print-line-fstr_println","text":"void fstr * str This function also uses fwrite to write to stdio, as well as printing out a newline character using printf . fstr * str = fstr_from_C ( \":) \" ); fstr_println ( str ); fstr_println ( str ); fstr_println ( str ); fstr_free ( str ); :) :) :)","title":"Print Line : fstr_println :"},{"location":"Printing/#print-characters-fstr_print_chrs","text":"void fstr * str This function writes each character individually using printf(\"%c\") . This is a MUCH slower but possibly more reliable print function in the case that fwrite doesn't properly work. fstr * str = fstr_from_C ( \"0x0x0x\" ); fstr_print_chrs ( str ); 0x0x0x","title":"Print Characters : fstr_print_chrs :"},{"location":"Printing/#print-characters-formatted-fstr_print_chrs_f","text":"void fstr * str chr * format This function prints out each individual character with the formatting applied. This does not take varargs . You must include the %c in the format fstr * str = fstr_from_C ( \"abc\" ); fstr_print_chrs_f ( str , \"[%c]\" ); fstr_free ( str ); [a][b][c]","title":"Print Characters Formatted : fstr_print_chrs_f :"},{"location":"Printing/#print-hex-codes-fstr_print_hex","text":"void fstr * str This function prints out each character as its hex code then adds a space separator. fstr * str = fstr_from_C ( \"hex text\" ); fstr_print_hex ( str ); fstr_free ( str ); 0x68 0x65 0x78 0x20 0x74 0x65 0x78 0x74","title":"Print Hex Codes : fstr_print_hex :"},{"location":"Removing/","text":"This is the set of functions relating to removing from strings. Remove At : fstr_remove_at : void usize index usize length Removes length amount of characters at index fstr * str = fstr_from_C ( \"0123456789\" ); fstr_println ( str ); fstr_remove_at ( str , 1 , 3 ); fstr_println ( str ); fstr_free ( str ); 0123456789 0456789 Remove String : fstr_remove : void fstr * str fstr * buf This function removes any instances of buf from the str . fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); fstr_println ( str ); fstr * buf = fstr_from_C ( \" \" ); //Remove all spaces fstr_remove ( str , buf ); fstr_println ( str ); fstr_free ( str ); fstr_free ( buf ); 01000001 01010111 01000011 01011001 00111111 0100000101010111010000110101100100111111 Remove C String : fstr_remove_C : void fstr * str chr * buf This function removes all instances of the buf C strings from within the str . fstr * str = fstr_from_C ( \"Whats up fam\" ); fstr_println ( str ); fstr_remove_C ( str , \" fam\" ); fstr_println ( str ); fstr_free ( str ); Remove Character : fstr_remove_chr : void fstr * str chr * c This function removes all instances of the singular character c . fstr * str = fstr_from_C ( \"1---1---1---1\" ); fstr_println ( str ); fstr_remove_chr ( str , '1' ); fstr_println ( str ); fstr_free ( str ); 1---1---1---1 --------- Remove Multiple Characters : fstr_remove_chr_varargs : void fstr * str int num_chars ... Removes a variable amount of chr s from the string. Takes in the number of characters to be replaced (the count of varargs) and the individual characters themselves. fstr * str = fstr_from_C ( \"The quick, brown fox. jumps over; the lazy dog.,\" ); fstr_println ( str ); fstr_remove_chr_varargs ( str , 3 , ',' , ';' , '.' ); fstr_println ( str ); fstr_free ( str ); The quick, brown fox. jumps over; the lazy dog., The quick brown fox jumps over the lazy dog","title":"Removing"},{"location":"Removing/#remove-at-fstr_remove_at","text":"void usize index usize length Removes length amount of characters at index fstr * str = fstr_from_C ( \"0123456789\" ); fstr_println ( str ); fstr_remove_at ( str , 1 , 3 ); fstr_println ( str ); fstr_free ( str ); 0123456789 0456789","title":"Remove At : fstr_remove_at :"},{"location":"Removing/#remove-string-fstr_remove","text":"void fstr * str fstr * buf This function removes any instances of buf from the str . fstr * str = fstr_from_C ( \"01000001 01010111 01000011 01011001 00111111\" ); fstr_println ( str ); fstr * buf = fstr_from_C ( \" \" ); //Remove all spaces fstr_remove ( str , buf ); fstr_println ( str ); fstr_free ( str ); fstr_free ( buf ); 01000001 01010111 01000011 01011001 00111111 0100000101010111010000110101100100111111","title":"Remove String : fstr_remove :"},{"location":"Removing/#remove-c-string-fstr_remove_c","text":"void fstr * str chr * buf This function removes all instances of the buf C strings from within the str . fstr * str = fstr_from_C ( \"Whats up fam\" ); fstr_println ( str ); fstr_remove_C ( str , \" fam\" ); fstr_println ( str ); fstr_free ( str );","title":"Remove C String : fstr_remove_C :"},{"location":"Removing/#remove-character-fstr_remove_chr","text":"void fstr * str chr * c This function removes all instances of the singular character c . fstr * str = fstr_from_C ( \"1---1---1---1\" ); fstr_println ( str ); fstr_remove_chr ( str , '1' ); fstr_println ( str ); fstr_free ( str ); 1---1---1---1 ---------","title":"Remove Character : fstr_remove_chr :"},{"location":"Removing/#remove-multiple-characters-fstr_remove_chr_varargs","text":"void fstr * str int num_chars ... Removes a variable amount of chr s from the string. Takes in the number of characters to be replaced (the count of varargs) and the individual characters themselves. fstr * str = fstr_from_C ( \"The quick, brown fox. jumps over; the lazy dog.,\" ); fstr_println ( str ); fstr_remove_chr_varargs ( str , 3 , ',' , ';' , '.' ); fstr_println ( str ); fstr_free ( str ); The quick, brown fox. jumps over; the lazy dog., The quick brown fox jumps over the lazy dog","title":"Remove Multiple Characters : fstr_remove_chr_varargs :"},{"location":"Replacement/","text":"","title":"Replacement"},{"location":"getting_started/","text":"To use fstr , download the latest release from Github Extract the zip and place the fstr.c and fstr.h files next to your source files in your program. If you want to use the parsing portion of the library, place fstr_parse.c and fstr_parse.h next to your source files. In the case that you use CMake , ensure that you include fstr.c and fstr_parse.c (if applicable) to the add_executable directive. add_executable ( PROJECT_NAME main.c ... fstr.c fstr_parse.c )","title":"Getting started"}]}